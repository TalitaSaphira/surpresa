#!/usr/bin/env python2
# -*- coding: utf-8 -*-

"""
Universidade Federal de Minas Gerais (UFMG) - 2023
Laboratorio CORO
Contact:
Joao Baiao, <baiaojfr.eng@gmail.com>
"""

import rospy
import tf
from std_msgs.msg import Float32MultiArray
from nav_msgs.msg import Odometry
import numpy as np
from geometry_msgs.msg import PoseWithCovarianceStamped
from numpy.linalg import norm

class Navigation_class:
    def __init__(self):
        # Navigation
        self.desired_velocity_b = [0.0, 0.0]
        self.desired_point_w = [0.0, 0.0]
        self.dist_ang = 0.0
        self.dist = 0.0
        self.origin_odom = [0.0, 0.0]
        self.C = []

        # Odometria
        self.pos = np.array([0.0, 0.0])
        self.quaternion = np.array([1.0, 0.0, 0.0, 0.0])

        # ROS
        self.freq = 30
        self.time_last = rospy.Time.now().to_sec()
        self.time_step = 0.1
        self.read_params()
        self.odom_sub = rospy.Subscriber(self.odometry_topic_name, PoseWithCovarianceStamped, self.pose_cb)
        self.inputs_pub = rospy.Publisher(self.input_topic_name, Float32MultiArray, queue_size=10)

    # ... (c贸digo anterior)

    def set_path(self, path):
        # tratamento dos dados de caminho a*
        for ponto in path:
            ponto[0] = self.square_side * (6 - ponto[0])
            ponto[1] = self.square_side * (ponto[1] - 1)

        x_coords, y_coords = zip(*path)

        distancia_maxima = 0.1
        numero_de_pontos_interpolados = int(np.sum(np.sqrt(np.diff(x_coords) ** 2 + np.diff(y_coords) ** 2) / distancia_maxima)) + 1

        indices_interpolados = np.linspace(0, len(x_coords) - 1, numero_de_pontos_interpolados)
        x_interpolados = np.interp(indices_interpolados, np.arange(len(x_coords)), x_coords)
        y_interpolados = np.interp(indices_interpolados, np.arange(len(y_coords)), y_coords)

        self.C = [y_interpolados, x_interpolados]  # Inverti x e y aqui para corresponder ao c贸digo original

    # ... (c贸digo anterior)

    def follow_field(self):
        self.desired_point_w = [self.C[1][-1], self.C[0][-1]]  # Inverti x e y aqui para corresponder ao c贸digo original
        self.dist = np.sqrt((self.pos[0] - self.desired_point_w[0]) ** 2 + (self.pos[1] - self.desired_point_w[1]) ** 2)

        while (self.dist > self.tol_trans):
            vetor_w = self.field_from_points()

            rot_wb = R.from_quat(self.quaternion).inv()
            vetor_b = rot_wb.apply(np.array([vetor_w[0], vetor_w[1], 0.0]))

            self.setMovement(vetor_b, 0)
            self.dist = np.sqrt((self.pos[0] - self.desired_point_w[0]) ** 2 + (self.pos[1] - self.desired_point_w[1]) ** 2)

        self.setMovement([0.0, 0.0], 0)
