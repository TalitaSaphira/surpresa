#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import rospy
import tf
from std_msgs.msg import Float32MultiArray
from nav_msgs.msg import Odometry
from geometry_msgs.msg import PoseWithCovarianceStamped
import numpy as np

class WheelOdometry:
    def __init__(self):
        rospy.init_node('wheel_odometry_node')

        self.listener = tf.TransformListener()

        self.freq = 30
        self.time_last = rospy.Time.now().to_sec()
        self.time_step = 0.1

        # Wheel velocities array
        self.u = np.array([0.0, 0.0, 0.0, 0.0])

        # Pose
        self.x = 0.0
        self.y = 0.0
        self.quaternion = np.array([1.0, 0.0, 0.0, 0.0])
        self.quaternion_imu = np.array([1.0, 0.0, 0.0, 0.0])

        self.read_params()

        self.odom_sub = rospy.Subscriber(self.odometry_topic_name, Odometry, self.odom_callback)
        self.vel_sub = rospy.Subscriber('/wheel_velocities', Float32MultiArray, self.velocity_callback)
        self.wheel_odom_pub = rospy.Publisher('/wheel/odom', Odometry, queue_size=10)

    def read_params(self):
        # Obtain the parameters
        self.l = float(rospy.get_param("~l", 1.0))
        self.w = float(rospy.get_param("~w", 1.0))
        self.r = float(rospy.get_param("~r", 1.0))

        self.odometry_topic_name = rospy.get_param("~odometry_topic_name", "gt")

    def odom_callback(self, msg):
        aux = [msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w]
        self.quaternion_imu = np.array(aux)

    def velocity_callback(self, msg):
        self.u = np.array(msg.data)
        time_now = rospy.Time.now().to_sec()
        self.time_step = time_now - self.time_last
        self.time_last = time_now

    def run(self):
        rate = rospy.Rate(self.freq)
        rate.sleep()

        while not rospy.is_shutdown():
            M = [[1, 1, 1, 1], [-1, 1, -1, 1], [-1 / (self.l + self.w), 1 / (self.l + self.w), 1 / (self.l + self.w),
                                              -1 / (self.l + self.w)]]
            [x_dot_b, y_dot_b, theta_dot] = (self.r / 4) * (np.dot(M, self.u))

            quaternion_x, quaternion_y, quaternion_z, quaternion_w = self.quaternion_imu

            rotation_matrix = np.array([
                [1 - 2*quaternion_y**2 - 2*quaternion_z**2, 2*quaternion_x*quaternion_y - 2*quaternion_z*quaternion_w, 2*quaternion_x*quaternion_z + 2*quaternion_y*quaternion_w],
                [2*quaternion_x*quaternion_y + 2*quaternion_z*quaternion_w, 1 - 2*quaternion_x**2 - 2*quaternion_z**2, 2*quaternion_y*quaternion_z - 2*quaternion_x*quaternion_w],
                [2*quaternion_x*quaternion_z - 2*quaternion_y*quaternion_w, 2*quaternion_y*quaternion_z + 2*quaternion_x*quaternion_w, 1 - 2*quaternion_x**2 - 2*quaternion_y**2]
            ])

            x_dot_b = 1.0  # Substitua pelo valor real de x_dot_b
            y_dot_b = 1.0  # Substitua pelo valor real de y_dot_b

            rotated_vector = np.dot(rotation_matrix, np.array([x_dot_b, y_dot_b, 0.0]))

            x_dot, y_dot, z_dot = rotated_vector[0], rotated_vector[1], rotated_vector[2]

            self.x += x_dot * self.time_step
            self.y += y_dot * self.time_step

            # Criar a mensagem Odometry e publicá-la
            odom_msg = Odometry()
            odom_msg.header.stamp = rospy.Time.now()
            odom_msg.header.frame_id = "wheel_odom"
            odom_msg.child_frame_id = "base_footprint"

            # Definir a posição
            odom_msg.pose.pose.position.x = self.x
            odom_msg.pose.pose.position.y = self.y
            odom_msg.pose.pose.position.z = 0.0

            # Converter theta para quaternion e definir a orientação
            odom_msg.pose.pose.orientation.w = self.quaternion[0]
            odom_msg.pose.pose.orientation.x = self.quaternion[1]
            odom_msg.pose.pose.orientation.y = self.quaternion[2]
            odom_msg.pose.pose.orientation.z = self.quaternion[3]

            # Configurar as informações de velocidade (twist)
            odom_msg.twist.twist.linear.x = 0.0
            odom_msg.twist.twist.angular.z = 0.0

            odom_msg.pose.covariance = [0.210, 9.6136e-05, 6.8828e-05, 0, 0, 0,
                                        9.6136e-05, 0.33, 5.5846e-05, 0, 0, 0,
                                        6.8828e-05, 5.5846e-05, 8.4270e-04, 0, 0, 0,
                                        0, 0, 0, 99999, 0, 0,
                                        0, 0, 0, 0, 99999, 0,
                                        0, 0, 0, 0, 0, 99999]

            # Publicar a mensagem odometry
            self.wheel_odom_pub.publish(odom_msg)

            rate.sleep()

if __name__ == '__main__':
    try:
        odometry = WheelOdometry()
        odometry.run()
    except rospy.ROSInterruptException:
        pass
