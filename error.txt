# Supondo que self.quaternion_imu seja um quaternion no formato [x, y, z, w]
quaternion = np.array([self.quaternion_imu.x, self.quaternion_imu.y, self.quaternion_imu.z, self.quaternion_imu.w])

# Converter o quaternion em uma matriz de rotação usando numpy
rotation_matrix = np.array([
    [1 - 2*quaternion[1]**2 - 2*quaternion[2]**2, 2*quaternion[0]*quaternion[1] - 2*quaternion[2]*quaternion[3], 2*quaternion[0]*quaternion[2] + 2*quaternion[1]*quaternion[3]],
    [2*quaternion[0]*quaternion[1] + 2*quaternion[2]*quaternion[3], 1 - 2*quaternion[0]**2 - 2*quaternion[2]**2, 2*quaternion[1]*quaternion[2] - 2*quaternion[0]*quaternion[3]],
    [2*quaternion[0]*quaternion[2] - 2*quaternion[1]*quaternion[3], 2*quaternion[1]*quaternion[2] + 2*quaternion[0]*quaternion[3], 1 - 2*quaternion[0]**2 - 2*quaternion[1]**2]
])

# Supondo que x_dot_b e y_dot_b sejam os componentes do vetor que você quer rotacionar
x_dot_b = 1.0  # substitua pelo valor real de x_dot_b
y_dot_b = 1.0  # substitua pelo valor real de y_dot_b

# Aplicar a rotação ao vetor [x_dot_b, y_dot_b, 0.0]
rotated_vector = np.dot(rotation_matrix, np.array([x_dot_b, y_dot_b, 0.0]))

# Agora rotated_vector contém os componentes x, y, z do vetor após a rotação
x_dot = rotated_vector[0]
y_dot = rotated_vector[1]
z_dot = rotated_vector[2]
