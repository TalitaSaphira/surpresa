import numpy as np

class Navigation_class:
    # ... (seu código anterior aqui)

    def get_yaw_from_quaternion(self):
        # Converte o quaternion para yaw em graus
        q = self.quaternion
        yaw = np.arctan2(2 * (q[3] * q[2] + q[0] * q[1]), 1 - 2 * (q[1]**2 + q[2]**2))
        return np.degrees(yaw)

    def rotate_to_this(self, yaw):
        # Muda orientacao do robo para yaw (referencial do mundo)
        current_yaw = self.get_yaw_from_quaternion()
        self.dist_ang = np.abs(current_yaw - yaw)

        while self.dist_ang > self.tol_angle:
            current_yaw = self.get_yaw_from_quaternion()
            self.dist_ang = np.abs(current_yaw - yaw)

            # Decida a direção de rotação mais curta
            if current_yaw > yaw:
                if self.dist_ang > 180:
                    self.setMovement([0.0, 0.0], -self.Krot)
                else:
                    self.setMovement([0.0, 0.0], self.Krot)
            else:
                if self.dist_ang > 180:
                    self.setMovement([0.0, 0.0], self.Krot)
                else:
                    self.setMovement([0.0, 0.0], -self.Krot)

        self.setMovement([0.0, 0.0], 0)
