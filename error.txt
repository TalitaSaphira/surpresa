import numpy as np

class Navigation_class:
    # ... (seu c처digo anterior)

    def quaternion_to_euler(self, quat):
        # Converte um quaternion para 창ngulos de Euler em graus
        x, y, z, w = quat
        roll = np.arctan2(2 * (w*x + y*z), 1 - 2*(x**2 + y**2))
        pitch = np.arcsin(2 * (w*y - z*x))
        yaw = np.arctan2(2 * (w*z + x*y), 1 - 2*(y**2 + z**2))

        # Convertendo de radianos para graus
        roll = np.degrees(roll)
        pitch = np.degrees(pitch)
        yaw = np.degrees(yaw)

        return roll, pitch, yaw

    def follow_field(self):
        self.desired_point_w = [self.C[0][-1], self.C[1][-1]]
        self.dist = np.sqrt((self.pos[0] - self.desired_point_w[0])**2 + (self.pos[1] - self.desired_point_w[1])**2)

        while self.dist > self.tol_trans:
            vetor_w = self.field_from_points()

            # Converte o quaternion para 창ngulos de Euler
            roll, pitch, yaw = self.quaternion_to_euler(self.quaternion)

            # Sua l처gica para o controle aqui, usando roll, pitch e yaw

            self.dist = np.sqrt((self.pos[0] - self.desired_point_w[0])**2 + (self.pos[1] - self.desired_point_w[1])**2)

        self.setMovement([0.0, 0.0], 0)
